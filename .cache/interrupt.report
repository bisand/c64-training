
; ******** Source: /home/bisand/dev/c64/c64-training/interrupt.asm
     1                                  ; --------------------------------
     2                                  ; JCH, DMC, Whatever IRQ music plr
     3                                  ; ================================
     4                                  * = $0801
     5                          
     6                          sysline:
     7  0801 0b0801009e323036...        !byte $0b,$08,$01,$00,$9e,$32,$30,$36,$31,$00,$00,$00 ; = SYS 2061
     8                          
     9                                  v = $d000
    10                          
    11                                  * = $080d                                             ; =2061 (Instead of $0810 as in Richards example
    12                                                                                        ; not to waste unnecessary bytes)
    13  080d a903                       lda #3
    14  080f 8d20d0                     sta $d020                       ; Set background color
    15                          
    16  0812 a90d                       lda #$d         ; Block 13
    17  0814 8df807                     sta $7f8        ; Sprite 0 pointer
    18  0817 a901                       lda #$01
    19  0819 8d15d0                     sta v+$15       ; Sprite 0 enable
    20  081c a903                       lda #$03
    21  081e 8d27d0                     sta v+$27       ; Sprite 0 color
    22  0821 a904                       LDA #$04        ; Sprite multicolor 0
    23  0823 8d25d0                     STA v+$25
    24                          
    25  0826 a23e                       ldx #$3e        
    26  0828 a900                       lda #$00
    27                          
    28                          clean
    29  082a 9d4003                     sta $340,x      ; load sprite data into mem block 13 (13 x 64)
    30  082d e8                         inx
    31  082e e03f                       cpx #63
    32  0830 d0f8                       bne clean
    33                          
    34  0832 a200                       ldx #0
    35                          build
    36  0834 bdd308                     lda data,x
    37  0837 9d4003                     sta $340,x      ; load sprite data into mem block 13 (13 x 64)
    38  083a e8                         inx
    39  083b d0f7                       bne build
    40                          
    41  083d a993                       lda #$93
    42  083f 20d2ff                     jsr $ffd2                       ; Clear screen
    43                          
    44  0842 78                         sei        ;disable maskable IRQs
    45                          
    46  0843 a97f                       lda #$7f
    47  0845 8d0ddc                     sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips
    48  0848 8d0ddd                     sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
    49                                              ;stop it.
    50                          
    51  084b ad0ddc                     lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.
    52  084e ad0ddd                     lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
    53                                          ;we don't want that to happen.
    54                          
    55  0851 a901                       lda #$01   ;this is how to tell the VICII to generate a raster interrupt
    56  0853 8d1ad0                     sta $d01a
    57                          
    58  0856 a900                       lda #$00   ;this is how to tell at which rasterline we want the irq to be triggered
    59  0858 8d12d0                     sta $d012
    60                          
    61  085b a91b                       lda #$1b   ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as
    62  085d 8d11d0                     sta $d011  ;the 9th bit for the rasterline we want our irq to be triggered.
    63                                          ;here we simply set up a character screen, leaving the topmost bit 0.
    64                          
    65  0860 a935                       lda #$35   ;we turn off the BASIC and KERNAL rom here
    66  0862 8501                       sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
    67                                          ;SID/VICII/etc are visible
    68                          
    69  0864 a972                       lda #<irq  ;this is how we set up
    70  0866 8dfeff                     sta $fffe  ;the address of our interrupt code
    71  0869 a908                       lda #>irq
    72  086b 8dffff                     sta $ffff
    73                          
    74  086e 58                         cli        ;enable maskable interrupts again
    75                          
    76  086f 4c6f08                     jmp *      ;we better don't RTS, the ROMS are now switched off, there's no way back to the system
    77                          
    78                          
    79                          irq
    80                          
    81                          ;Being all kernal irq handlers switched off we have to do more work by ourselves.
    82                          ;When an interrupt happens the CPU will stop what its doing, store the status and return address
    83                          ;into the stack, and then jump to the interrupt routine. It will not store other registers, and if
    84                          ;we destroy the value of A/X/Y in the interrupt routine, then when returning from the interrupt to
    85                          ;what the CPU was doing will lead to unpredictable results (most probably a crash). So we better
    86                          ;store those registers, and restore their original value before reentering the code the CPU was
    87                          ;interrupted running.
    88                          
    89                          ;If you won't change the value of a register you are safe to not to store / restore its value.
    90                          ;However, it's easy to screw up code like that with later modifying it to use another register too
    91                          ;and forgetting about storing its state.
    92                          
    93                          ;The method shown here to store the registers is the most orthodox and most failsafe.
    94                          
    95  0872 48                         pha        ;store register A in stack
    96  0873 8a                         txa
    97  0874 48                         pha        ;store register X in stack
    98  0875 98                         tya
    99  0876 48                         pha        ;store register Y in stack
   100                          
   101  0877 a9ff                       lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.
   102  0879 8d19d0                     sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end
   103                                          ;up having the CPU running the interrupt code all the time, as when it exists the
   104                                          ;interrupt, the interrupt request from the VICII will be there again regardless of the
   105                                          ;rasterline counter.
   106                          
   107                                          ;it's pretty safe to use inc $d019 (or any other rmw instrction) for brevity, they
   108                                          ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.
   109                          
   110                          ; Start Code
   111                          
   112                          up
   113  087c ad00dc                 lda $DC00
   114  087f 2901                   and #$1
   115  0881 d003                   bne down
   116  0883 ced208                 dec spry
   117                          down
   118  0886 ad00dc                 lda $DC00
   119  0889 2902                   and #$2
   120  088b d003                   bne left
   121  088d eed208                 inc spry
   122                          left
   123  0890 ad00dc                 lda $DC00
   124  0893 2904                   and #$4
   125  0895 d008                   bne right
   126  0897 ced008                 dec sprx
   127  089a d003                   bne right
   128  089c ced108                 dec sprx+1
   129                          right
   130  089f ad00dc                 lda $DC00
   131  08a2 2908                   and #$8
   132  08a4 d008                   bne fire
   133  08a6 eed008                 inc sprx
   134  08a9 d003                   bne fire
   135  08ab eed108                 inc sprx+1
   136                          fire
   137  08ae ad00dc                 lda $DC00
   138  08b1 2910                   and #$10
   139  08b3 d003                   bne done
   140  08b5 ee20d0                 inc $d020
   141                          done
   142  08b8 add008                 lda sprx
   143  08bb 8d00d0                 sta v
   144  08be add108                 lda sprx+1
   145  08c1 8d10d0                 sta v+$10
   146  08c4 add208                 lda spry
   147  08c7 8d01d0                 sta v+1
   148                          
   149                          ; End Code
   150                          
   151  08ca 68                         pla
   152  08cb a8                         tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)
   153  08cc 68                         pla
   154  08cd aa                         tax        ;restore register X from stack
   155  08ce 68                         pla        ;restore register A from stack
   156                          
   157  08cf 40                         rti        ;Return From Interrupt, this will load into the Program Counter register the address
   158                                          ;where the CPU was when the interrupt condition arised which will make the CPU continue
   159                                          ;the code it was interrupted at also restores the status register of the CPU
   160                          
   161  08d0 6400               sprx    !byte 100,0
   162  08d2 64                 spry    !byte 100
   163                          
   164                          data 
   165  08d3 0000000600000900           !byte $00,$00,$00,$06,$00,$00,$09,$00
   166  08db 000cc0000c7f000b           !byte $00,$0c,$c0,$00,$0c,$7f,$00,$0b
   167  08e3 ed801fecc015f640           !byte $ed,$80,$1f,$ec,$c0,$15,$f6,$40
   168  08eb 136ee0165fa01f3e           !byte $13,$6e,$e0,$16,$5f,$a0,$1f,$3e
   169  08f3 a01fdfc00fffe008           !byte $a0,$1f,$df,$c0,$0f,$ff,$e0,$08
   170  08fb d1c00cf22007edc0           !byte $d1,$c0,$0c,$f2,$20,$07,$ed,$c0
   171  0903 00f8000000000000           !byte $00,$f8,$00,$00,$00,$00,$00,$00
   172  090b 0000000000000005           !byte $00,$00,$00,$00,$00,$00,$00,$05
